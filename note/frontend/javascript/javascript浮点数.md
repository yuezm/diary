有一道很常见的面试题

```
0.1 + 0.2 === 0.3 // true ? false
```

大家应该都知道是 false，那么有没有想过为什么呢？下面我将从 **浮点数表示**及**浮点数运算**两个方面来解释

## Javascript 浮点数表示

Javascript 中不存在整型和浮点型之分，只有一个类型 _Number_，它遵循 IEEE 二进制浮点数算术标准（IEEE754）,使用 64 位*双精度浮点数（double）*存储。

那么双精度浮点数是如何存储数据呢？主要有几个关键点

**双精度浮点数使用 64 位存储**

![](https://user-gold-cdn.xitu.io/2019/9/8/16d102b50b9f66d8?w=594&h=96&f=png&s=1504)

- sign（S）：符号位，长度为 1，0 代表数字为正，1 代表数字为负
- exponent（E）：指数位，长度为 11，二进制科学计数法的指数位
- mantissa（M）：尾数位，长度为 52 ，二进制科学计算法的尾数位

数值的计算公式为： $value = (-1)^S * 2^E * M$

**使用*二进制科学计数法***

举个栗子：  
$0.5_{10}$ 转换为二进制表示 $0.1_2$  
$0.1_2$ 转换为二进制科学计数法 $1*2^{-1}$

**指数位表示有符号整数**

因为指数为无符号整数，且数值为 [0,2047]，在*规格化值*中取 [1,2046]。如果表示为有符号整数时，则[1,1022] 表示为负数[-1022,-1]，1023 表示为 0，[1024,2046]表示为正数[1,1023]，由此可得公式

$$E = e - Bias = e - 1023$$

所以二进制科学计数法$1*2^{-1}$，该数 E = -1，则 e = 1022

tips: 下面会讲什么是*规格化值、非规格化值、特殊值*

**尾数不表示二进制科学计算的整数部分，即不表示 1**

由于规格化的数整数位都是 1，所以在存储时可以节约空间，不表示整数位，从小数位开始表示，由此可得公式

$$M = 1 + f$$

所以二进制科学计数法$1*2^{-1}$，该数 M=1，则实际存储时 f=0，

**由上可将数值计算公式推导为**
$$ value = (-1)^S * 2^{e-1023} * (f + 1) $$

## 非规格化值 和 特殊值

细心的童鞋可能会想到，如果按公式 $ M = f + 1 $，那么如何表示 0 呢？，即使你设 f = 0，e=任意值，按照公式算出，value 不可能为 0。当然第一个公式 $value = (-1)^S * 2^E * M$ 没有问题，问题出在公式的推导，因为推导公式只符合规格化数值

规格化数值：e 不全为 0，也不全为 1，f 为任意值  
非规格化数值：e 为 0，f 为任意数值，此时公式为 $ E = e - Bias $，$ M = f $，则推导出非规格化公式为
$$ value = (-1)^S * 2^{e-1023} * f $$  

无穷大：e全部为1，f全部为0
NaN：e全部为1，f不全部为0

## Javascript 浮点数计算
