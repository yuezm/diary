## 作用域是什么

**作用域** 维护所有声明标识符的（变量）的查询，并且限制当前代码对这些标识符的访问权限。

1. 维护变量的声明及查询。作用域查询分为 LHS、RHS（简单理解为赋值操作（=）的左边还是右边）
   - **LHS** 寻找赋值的目标
   - **RHS** 寻找赋值的源头，即寻找值
2. 维护代码对变量的访问权限

**注意点** LHS 和 RHS 非严格按照等号划分，而是按照作用（是*寻找赋值的目标*还是*寻找值*）来划分，如下代码所示

```javascript
// LHS a
function fn(a) {
  // RHS console
  // RHS a
  console.log(a);
}
fn(1);
```

此处调用 `fn(1)` 时不存在等号，但是还是存在 LHS：

```text
RHS：寻找标识符 fn
LHS：将 a 赋值为 1
RHS：寻找标识符 console，并调动 log 方法
RHS：寻找 标识符 a
```

## Javascript 作用域

尽管将 Javascript 归为解释性语言，但事实上它是一门编译性语言。一般编译性语言分为如下几个阶段：_词法解析 => 语法解析 => 代码生成_ 。Javascript 与常规编译性语言不同的是，它的编译时间并不长，通常为执行前的几毫秒甚至更少，然后通过其他手段（例如 JIT）来提高性能 <sub>[1]</sub>

下图是为编译器，引擎，作用域的对话，整理自《你不知道的 Javascript》

![](https://public.keven.work/Javascript%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg)

作用域主要包含两种工作模型：_词法作用域、动态作用域_

- **词法作用域（静态作用域）** 在词法解析阶段定义的作用域。即是由代码的书写顺序来决定作用域。
- **动态作用域** 运行时根据程序的流程信息来动态确定作用域。_有没有觉得很像 this_，但需要注意，Javascript 是没有动态作用域的，而 this 表现很像动态作用域

### 欺骗词法

Javascript 具有欺骗词法的手段，`with、eval`（不建议这样玩，当个老老实实的程序员）

#### eval

```javascript
eval('var a = 2');
```

**非严格模式**

在非严格模式下，eval 在**当前作用域**插入变量

```javascript
eval('var a = 3');
console.log(a); // 3
```

**严格模式**
在严格模式下，eval 重新创建作用域

```javascript
'use strict';
eval('var a = 3');
console.log(a); // 报错
```

**除了 eval 以外，也可以使用 setTimeout 和 setInterval 也可以插入字符串来执行**

```javascript
const str = 'console.log(1)';
setTimeout(str, 1000); // 1
```

<font color="red">非常不建议使用！</font>

#### with

**严格模式下 with 无法使用**

```javascript
'use strict';

// 报错 SyntaxError
with ({ name: 'keven' }) {
}
```

with 引入对象，将对象处理为一个新的词法作用域，但 with 内部的 <font color="red">var</font> 变量声明**不会保留在该块级作用域**，而是**保留在 with 的作用域**。（注意噶，是 var 声明，但 let、const 声明是保存在块级作用域的）

## Javascript 作用域分类

1. 全局作用域：每个执行环境只有一个全局作用域，浏览器是 `window`，node.js 为 `global`

```javascript
window.x = 1;
global.x = 1;
```

2. 函数作用域：每一个函数会单独创建函数作用域

```javascript
function fn() {
  let x = 1;
}
```

3. 块级作用域：ES6 中增加块级作用域，在 `{}` 中以 `let、const` 声明的变量存在块级作用域

```javascript
{
  let x = 1;
}
```

4. 中间作用域：ES6 中增加中间作用域，在 **函数**且**函数存在默认值**时，函数的默认值即为中间作用域

请注意这个作用域，标准里并不含该作用域。如果想详细地了解该作用域，请点击 --> [ES6: Default values of parameters](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#conditional-intermediate-scope-for-parameters)

```javascript
function fn(x = 1) {
  console.log(x); // 1，如果 x 无默认值，则是 undefined
  var x = 2; // 不要用let、const去试哈，由于TDZ关系，会报错
  console.log(x); // 2
}
```

## 作用域嵌套

把作用域看成一个气泡，父级作用域是一个大气泡，包裹着子作用域的小气泡，全局作用域是一个最大的气泡，包裹其他的气泡。

当开始寻找变量时，从自身作用域开始，逐级向上查找，直到全局作用域

```javascript
window.x = 1;

function p() {
  function c() {
    x = 3;
  }
}
```

## 作用域提升

上面提到了在 Javascript 执行前，存在编译过程（预解析），在此过程中会解析**函数声明**、**变量声明**。

对于变量声明来说，是将 _定义声明_ 和 _赋值声明_ 分开的

```javascript
var a = 1;

// 可以翻页为
var a; // 定义声明
a = 1; // 赋值声明
```

**优先顺序**：函数声明提升**优先于**变量声明

```javascript
console.log(fn); // Function
function fn(params) {}
var fn = 2;
```

### TDZ

**TDZ（Time Dead Zone）** 在 ES6 中，对 `let、const` 声明时，TDZ 使无法在 `let、const` 赋值语句前访问该变量。

**TDZ 原理** let/const 声明和 var 声明一样，都会致使变量提升，这是 javascript 的特性。但预解析时 let/const **只能创建变量，无法进行词法绑定**，词法绑定是在赋值运算时完成的，在赋值运算前访问变量（无论是 RHS 还是 LHS）会抛出 `ReferenceError`。在变量创建（预解析）到可以访问变量的这一段时间称为 TDZ。

## 闭包

**闭包** 函数可以记住、并访问原作用域（在非原作用域的地方，但可以访问原作用域变量的功能）

```javascript
function p() {
  const a = 1;
  return function c() {
    console.log(a);
  };
}

const c = p();
c(); // 此时c处于全局作用域，但任然可以访问变量a

// [[Scopes]]; 可以打印下 p.prototype，里面存在 [[ Scopes ]] 属性，可以查看作用域
```

### IIFE（立即调用函数表达式）

对于自执行函数，按照闭包的定义，其实 IIFE 严格来说不属于闭包，_因为在 IIFE 函数中，并**不是在当前作用域以外的地方执行的**_

```javascript
(function () {
  let x = 1;
})(); // 它就是在当前作用域执行的，而不是在外部作用域执行的
```

[1] 你不知道的 Javascript 上卷
