# 查找第一期-单词查找树

## 什么是单词查找树

单词查找树又称 Trie 树、字典树，是一种树形结构，主要作用是**取出数据**

Trie 树特性：

1. 根节点不存在字符，其他每个节点只存在一个字符。其根节点的存在只是为了简化查询操作，并无其他的特殊意义
2. 从根节点到某个节点的路径连接起来时，就是一个字符串
3. 每个节点的子节点所包含在**字符唯一**

## Trie 树的作用

1. 单词查找（不然为啥叫单词查找树嘛）
2. 词频率统计

### Trie 树优势

1. 查找命中所需要的时间与被查单词的长度成正比，即时间复杂度为 O(L)，L 为查找字符串长度
2. 查找未命中只需要查找若干个字符，设查询字符数为 N，则（N<=L）

**字典树与其他查找方式比较**

和遍历相比
举个例子，现在存在一堆数据，"tree","trie"，"com"，"cn"，我现在想要查询，这堆数据是否包含以 "co"开始的字符，使用遍历法

1.  如果首字符匹配 'c'，则进入下一步骤，否则终止遍历当前字符，并重新回到步骤 1
2.  如果匹配字符"o"，则表示匹配成功，返回 true
3.  当遍历完整堆数据时，都未找到匹配值，返回 false

是不是觉得还阔以，最大比较 4 \* 2 O(N\*L) 就结束了，但是这里的样本只有 4 个单词，如果是牛津词典呢，遍历一次牛津词典，那不就爆炸了。而使用单词查找树，可以在 O(L)的时间内出结果，这是性能的巨大提升

和散列表相比

单纯的对于查询，散列表可以做到 O(1)，这难道还有比 O(1)更快的算法？那字典树还能有啥优势？

其实散列表相较于 Trie 树存在两个缺点

1.  散列表需要存储每个字符串，而 Trie 树可以压缩空间，Trie 树对于相同前缀的字符串，是存储到一起的，例如 tree，和 trie，tr 占用同一个空间
2.  散列表无法查询前缀，因为散列算法时基于整个字符串的，例如无法查询 "tr"

### R 向 Trie 树

R 向单词查找树：每个节点都存在 R 条链接，R 为常数，举个例子，如果只是查询英文字符，则 R 为 256，查询英文单词，则 R 为 52。R 向单词查找树可能会存在很多的空键，所以在绘制单词查找树一般忽略空键。

## Trie 树的操作

此处演示代码，均认为字符只存在小写英文 26 个字符，采用 **R 向单词查找树**，R=26

```typescript
class TrieTree {
  init(): void;
  get(key: string): string | null; // 查询操作
  put(key: string, value: string): void; // 插入
}
```

### 单词查找树查找

单词查找树的每个节点都存储了，下一个节点所包含的所有可能的字符链接。

在查询时，可能遇到如下情况

1. 查询键对应节点的值，则此次为命中查询，继续下一次
2. 查询键不对应任何节点，则此次为非命中查询，直接结束
3. 查询键为空，则整个查询结束

### 单词查找树插入

### 单词查找树删除

## 三向单词查找树

## 中文可咋整
