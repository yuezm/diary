# 并查集

## 什么是并查集

其实并查集这个名称已经完全解释了这个数据结构了

```text
并：合并数据
查：查找数据
集：数据的集合
```

即并查集就是一个可以合并数据，也可以查询数据的集合。当然这是个人理解的白话，下面用正儿八经的文字解释（其实就是 Google 搜了下定义）

并查集：是一种树形数据结构，主要用于**不交集的合并**以及**查询**问题。有一个**联合-查询算法**定义了两个用于此数据结构的操作。

众所周知，数据结构包含 _数据+操作_，数据等下面再详细介绍，这里主要列举下并查集的两个基本操作：

- Union：将两个子集合并。例如 联合 (1) 和 (5) 集合，合并为一个集合
- Find：查找元素的源头，即查找目标节点的根节点。例如查找 (3)

![并查集.jpg](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86.jpg)

## 并查集能干点啥

判断两个节点是否连通（图的连通）

## 并查集引入（举个例子）

三个国家进行战争，三个军队首脑分别为 (1) ， (5) ， (8) 。由于军队人数非常庞大，不可能所有人都直接听从首脑调遣，则依照下图所示，_首脑只听从自己调遣，其他人只听从自己直线上级调遣_（这意味着小兵只认识自己的直线上级，不存在越级的情况）

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E5%8A%BF%E5%8A%9B%E8%8C%83%E5%9B%B4.jpg)

**战争满足一下特点，即战争规则**：

1. 国家不同士兵见面就打仗
2. 国家相同的士兵不会打仗
3. 首领只听从自身调遣，即首领的直属上级就是自己
4. 士兵听命于直属上级调遣

### 第一个例子：Union 单个节点

**(8) 招募**：由于 (8) 的军队人数实在是太少了，为了鼓舞士气， (8) 决定招募了一个大佬，于是招募到了 (9) ，直接听命于 (8)

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E5%90%88%E5%B9%B62.jpg)

### 第二个例子：Union 两个集合

**(5) 打败 (8)**： (5) 打败 (8) 后，那么两个国家就需要合并成为一个国家，此时有个问题，是 **(5) 合并到 (8) ？还是 (8) 合并到 (5)？**

直观得看上去 (5) 的 “势力” 是大于 (8) 的，按照一般的思维，是势力小的依附于势力大的，所以应该是 (8) 合并到 (5) 。这种合并方式，也就是后面要讲述的 **按秩合并**

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E5%90%88%E5%B9%B61.jpg)

### 第三个栗子：Find

**(23) 、 (45) 相遇**：当两个军队相遇了，这时候引出了个问题：**他们到底是打仗呢还是不打呢？**

首先我们明确下规则，根据战争规格 1、2，只需要判断 (23) 和 (45) 是否属于同一个国家就行了。那么问题由 **是否打仗？** => **是否为同一个国家？**

那么我们根据什么来评判 (23) 和 (45) 是同一个国家呢？比较直观的想法就是，分别找到 (23) 和 (45) 的国家，比较是不是一个国家就行了。那么问题由 **是否为同一个国家？** => **寻找到每个军队的国家**。由于相同首领的国家必然是相同的，则 **寻找到每个军队的国家** => **寻找每个军队的首领**

推导至此，我们只需要找到每个军队的首领（也就是找到每个节点的根节点）就行了，那么以 (23) 为例，按照以下步骤即可找到自己的首领

1. 由于 (23) 属于 (22) ：则 (22) 的国家也就是 (23) 的国家
2. 由于 (23) 属于 (2) ：则 (2) 的国家也就是 (22) 、 (23) 的国家
3. 由于 (2) 属于 (1) ：则 (1) 的国家也就是 (2) 、 (22) 、 (23) 的国家
4. 由于 (1) 属于 (1) ：根据战争规则 3、4 推出，只有首领才听命于自己，则 (1) 就是 (23) 的首领，也就是说 (1) 是 (23) 的根节点

重复以上步骤，推导出 (45) 的首领也是 (1) （ (45) 的根节点也是 (1) ），则 (45) 和 (23) 首领相同，则必然国家也相同，所以 **(23) 和 (45) 不应该打仗**

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E6%9F%A5%E6%89%BEjpg)

## 并查集代码实现

### 数据

#### 对象存储

按照上面的思路，大致想法如下：

1. 树形存储，想都不用想，直接先整个树形结构先

   ```typescript
   class TreeNode {
     value: number;
     children: TreeNode[] | null; // 不知道子节点有多少个
   }
   ```

2. 树形结构整出来了，发现有点不太对，没得父级表示，没办法向上面步骤那样，从子找到父。脑壳一拍，那就加个父级嘛

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
     children: TreeNode[] | null;
   }
   ```

3. 开心满满得定义完节点了，再次梳理下 Find 步骤和 Union 步骤，发现根本不需要从父找到子，只需要从子找到父，那么 `children` 完全是浪费嘛，果断去了

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
   }
   ```

这下就科学多了，最终的 TreeNode 就是树形中的节点定义

#### 数组存储

由 "对象存储" 推导出一个关键点：_只需要子找到父即可，父不比知道子节点_，则可以使用数组存储，以数组的 index 表示子节点，以 array[index] 表示该子节点的父节点，表现为 `array[index]=parent`；根节点的等于自身，表现为 `array[root] = root`;

```typescript
class UnionFind {
  private findUnionList: number[];

  constructor(max: number) {
    this.findUnionList = new Array(max);
  }
}
```

后续实例代码都使用数组存储

### Find

```typescript
class UnionFind {
  private findUnionList: number[];

  constructor(max: number) {
    this.findUnionList = new Array(max);
  }

  find(x: number): number | undefined {
    // 如果 x 为 undefined，则表示 x 在集合中不存在
    while (x !== this.findUnionList[x] && x !== undefined) {
      x = this.findUnionList[x];
    }
    return x;
  }
}
```

### Union

```typescript
class UnionFind {
  private findUnionList: number[];

  constructor(max: number) {
    this.findUnionList = new Array(max);
  }

  find(x: number): number | undefined {
    while (x !== this.findUnionList[x] && x !== undefined) {
      x = this.findUnionList[x];
    }
    return x;
  }

  setNodeParent(childIndex: number, parentValue: number): void {
    this.findUnionList[childIndex] = parentValue;
  }

  union(x: number, y: number) {
    const rootX: number | undefined = this.find(x);
    const rootY: number | undefined = this.find(y);

    if (rootX === undefined && rootY === undefined) {
      // x，y 都不在集合中，则将 x 设为根节点
      this.setNodeParent(x, x);
      this.setNodeParent(y, x);
    } else if (rootX === undefined) {
      // rootY 必不为空，则 y 在集合必然存在
      this.setNodeParent(x, y);
    } else if (rootY === undefined) {
      // rootX 必不为空,则 x 必然在集合中
      this.setNodeParent(y, x);
    } else {
      this.setNodeParent(rootY, rootX);
    }
  }
}
```

## 路径压缩

观察 find 方法，每次 Find 操作时，都需要从 子->父->父...父->->根 去查找，如果只是几个节点那还好，如果节点数到达 1 千个、1 万个、10 万个...，显而易见的查询效率会越来越低。那么有没得啥子办法来提高查询效率？

我们观察查询步骤，发现父节点对于子节点的意义只是为了*做为跳板，去查询根节点的*，那么直接将子节点的 parent 指向根节点，每次检查都只需要一次查询就完工咯。你可以看成把一颗"高瘦的"树变成一棵"矮胖的"树

既然知道了优化的办法了，下面列举两种不同的实现方法

### 一步到位

一步到位：一次 Find 操作，就将该链上的节点全部指向根节点

```typescript
```

### 循序渐进

循序渐进：如果是一步到位是个激进派，那么循序渐进就是一个保守派。它并不是直接指向根节点，而是每次把父级往前移动一个，原来是 子->父，现在是 子->(父->父)，表现为 `array[index] = array[array[index]]`

```typescript
```

## 按秩合并

我们拿 (5)和(8)合并来说：

1. 原来(5)的最远节点 Find 操作需要 4 次查询操作才能找到根节点
2. 原来(8)的最远节点 Find 操作需要 2 次查询操作才能找到根节点

最大查询次数 maxFind = 4;

我们现在按照两种合并方式，合并(5)和(8)

**(5)合并到(8)**

现在(8)的最远节点 Find 操作需要 5 次查询操作才能找到根节点，比原先最大的查询次数多了 1 次

**(8)合并到(5)**

现在(5)的最远节点 Find 操作需要 4 次查询操作才能找到根节点，与原先最大查询次数未改变

由上对比，显而易见，(8)合并到(5)性能更好（虽然只有 1 次之差，哈哈）

接下来，我们想一想为什么勒，继续回到查询步骤，我们的查询是这样的 子->父->父->根，这查询次数不就是树的深度嘛

那么我们得到了结论：将深度小的树合并到深度大的树可以获得更好的性能
