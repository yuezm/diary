# 并查集

## 什么是并查集

其实并查集这个名称已经完全解释了这个数据结构了

```text
并：合并数据
查：查找数据
集：数据的集合
```

即并查集就是一个可以合并数据，也可以查询数据的集合。当然这是个人理解的白话，下面用正经的文字解释（其实就是 Google 搜了下定义）

并查集：是一种树形数据结构，主要用于**不交集的合并**以及**查询**问题。有一个**联合-查询算法**定义了两个用于此数据结构的操作。

众所周知，数据类型包含 _数据+操作_，数据等下面再详细介绍，这里主要列举下并查集的基本操作：

- Union：将两个子集合并。例如 联合 (1) 和 (5) 集合，合并为一个集合
- Find：查找元素的源头，即查找目标节点的根节点。例如查找 (3)

![并查集.jpg](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86.jpg)

## 并查集引入（举个例子）

三个国家进行战争，三个军队首脑分别为 (1) ， (5) ， (8) 。由于军队人数非常庞大，不可能所有人都直接听从首脑调遣，则依照下图所示，_首脑只听从自己调遣，其他人只听从自己直线上级调遣_（这意味着小兵只认识自己的直线上级，不存在越级的情况）

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E5%8A%BF%E5%8A%9B%E8%8C%83%E5%9B%B4.jpg)

**战争满足一下特点，即战争规则**：

1. 国家不同士兵见面就打仗
2. 国家相同的士兵不会打仗
3. 首领只听从自身调遣，即首领的直属上级就是自己
4. 士兵听命于直属上级调遣

### 第一个例子：Union 单个节点

**(8) 招募**：由于 (8) 的军队人数实在是太少了，为了鼓舞士气， (8) 决定招募了一个大佬，于是招募到了 (9) ，直接听命于 (8)

### 第二个例子：Union 两个集合

**(5) 打败 (8)**： (5) 打败 (8) 后，那么两个国家就需要合并成为一个国家，此时有个问题，是 **(5) 合并到 (8) ？还是 (8) 合并到 (5)？**

直观得看上去 (5) 的 “势力” 是大于 (8) 的，按照一般的思维，是势力小的依附于势力大的，所以应该是 (8) 合并到 (5) 。这种合并方式，也就是后面要讲述的 **按秩合并**

### 第三个栗子：Find

**(23) 、 (45) 相遇**：当两个军队相遇了，这时候引出了个问题：**他们到底是打仗呢还是不打呢？**

首先我们明确下规则，根据战争规格 1、2，只需要判断 (23) 和 (45) 是否属于同一个国家就行了。那么问题由 **是否打仗？** => **是否为同一个国家？**

那么我们根据什么来评判 (23) 和 (45) 是同一个国家呢？比较直观的想法就是，分别找到 (23) 和 (45) 的国家，比较是不是一个国家就行了。那么问题由 **是否为同一个国家？** => **寻找到每个军队的国家**。由于相同首领的国家必然是相同的，则 **寻找到每个军队的国家** => **寻找每个军队的首领**

推导至此，我们只需要找到每个军队的首领（也就是找到每个节点的根节点）就行了，那么以 (23) 为例，按照以下步骤即可找到自己的首领

1. 由于 (23) 属于 (22) ：则 (22) 的国家也就是 (23) 的国家
2. 由于 (23) 属于 (2) ：则 (2) 的国家也就是 (22) 、 (23) 的国家
3. 由于 (2) 属于 (1) ：则 (1) 的国家也就是 (2) 、 (22) 、 (23) 的国家
4. 由于 (1) 属于 (1) ：根据战争规则 3、4 推出，只有首领才听命于自己，则 (1) 就是 (23) 的首领，也就是说 (1) 是 (23) 的根节点

重复以上步骤，推导出 (45) 的首领也是 (1) （ (45) 的根节点也是 (1) ），则 (45) 和 (23) 首领相同，则必然国家也相同，所以 **(23) 和 (45) 不应该打仗**

## 并查集代码实现

### 数据

#### 树形存储

按照上面的思路，大致想法如下：

1. 树形存储，想都不用想，直接先整个树形结构先

   ```typescript
   class TreeNode {
     value: number;
     children: TreeNode[] | null; // 不知道子节点有多少个
   }
   ```

2. 树形结构整出来了，发现有点不太对，没得父级表示，没办法向上面步骤那样，从子找到父。脑壳一拍，那就加个父级嘛

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
     children: TreeNode[] | null;
   }
   ```

3. 还是有点不太对，我根本不需要从父找到子，只需要从子找到父，那么 `children` 完全是浪费嘛，果断去了

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
   }
   ```

这下就科学多了，

### Union

### Find

## 路径压缩

## 按秩合并
