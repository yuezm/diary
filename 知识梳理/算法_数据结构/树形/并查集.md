# 并查集

## 什么是并查集

其实并查集这个名称已经完全解释了这个数据结构了

```text
并：合并数据
查：查找数据
集：数据的集合
```

即并查集就是一个可以合并数据，也可以查询数据的集合。当然这是个人理解的白话，下面用正儿八经的文字解释（其实就是 Google 搜了下定义）

并查集：是一种树形数据结构，主要用于**不交集的合并**以及**查询**问题。有一个**联合-查询算法**定义了两个用于此数据结构的操作。

众所周知，数据类型包含 _数据+操作_，数据等下面再详细介绍，这里主要列举下并查集的基本操作

- Union：将两个子集合并。例如 联合 (1) 和 (5) 集合，合并为一个集合
- Find：查找元素的源头，即查找目标节点的根节点。例如查找 (3)

## 并查集作用

并查集主要用于**判断是否连通**，简单来说就是判断其中一个节点能否经过任意路径达到另一个节点，如果可达则为连通。例如可以用来判断某两个局域网的电脑是否可以互相访问

### 并查集引入

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_%E5%BC%95%E5%85%A5.jpg)

如何判断路人甲和路人乙是否是亲戚？

1. 题目分析，路人甲和路人乙是亲戚的条件是 "是否祖先曾相同过，且不管辈分"，则问题转移，表现为 "是否为亲戚？" => "祖先是否曾相同？"

2. 对上一个问题分析，祖先是否相同不好一眼识别，想个好办法，找出路人甲的祖先以及路人乙的祖先，然后对比两个人是否为同一个人，则问题转移，表现为 "祖先是否相同=>找出两个人的祖先，然后比较是否相同"

#### Find 引入

拿路人甲来举例，如何查询路人甲的祖先？根据人的一般思维做出**Find 步骤推导**

1. 查询路人甲的父亲：路人甲 -> 甲父
2. 查询路人甲的父亲的父亲：甲父 -> 甲爷
3. 查询路人甲...：甲爷 -> 甲太爷
4. 查询路人甲...：发现他太爷上面没人了，则路人甲的祖先就是甲太爷

同理查询处路人乙的祖先是乙父，甲太爷 != 乙父，则路人甲和路人乙不是亲戚

![](https://public.keven.work/%E5%B9%B6%E6%9F%A5%E9%9B%86_FInd.jpg)

#### Union 引入

突然有一天，甲爷发现乙父是失散多年的儿子，准备让乙父认祖归宗，则此时甲爷和乙父建立了关系。那么此时路人甲和路人乙是否是亲戚？

按照 Find 步骤求得 甲太爷==甲太爷，则路人甲和路人乙是亲戚

## 并查集代码实现

### 数据初始化

#### 树形存储

按照上面绘制的图形，甲太爷下面有甲叔公、甲爷；甲爷下面有甲父...，很明显是一个树形结构

1. 分析出了树形结构，想都不用想，直接先整个树形结构先

   ```typescript
   class TreeNode {
     value: number;
     children: TreeNode[] | null; // 不知道子节点有多少个，所以用数组存储
   }
   ```

2. 树形结构整出来了，发现有点不对，按照 **Find 步骤推导**，子级必须可以找到父级，但是这里子级都没有存储父级，不可能从子级找到父级。脑壳一拍，那就加个父级嘛

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
     children: TreeNode[] | null;
   }
   ```

3. 打完收工，收工到一半发现还是有点不太对，按照**Find 步骤推导**，我根本不需要从父级找到子级，只需要从子及找到父及，那么 `children` 完全是浪费嘛，果断去了

   ```typescript
   class TreeNode {
     value: number;
     parent: TreeNode;
   }
   ```

这下就科学多了，终极存储节点搞定了

### Union

### Find

## 路径压缩

## 按秩合并
