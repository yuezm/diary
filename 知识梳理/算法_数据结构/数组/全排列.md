# 全排列

全排列：给定一组数据，列出所有可能的排列。举个栗子

```text
  [1,2,3]  ==>  [1,2,3]，[1,3,2]，[2,1,3]，[2,3,1]，[3,1,2]，[3,2,1]
```

## 回溯法

假设有 n 个空位，每次从从剩余的数字中，取出一个数字，放入空位中，空位放置满后，即为一个排列

拿 [1,2,3] 来说

```text
[null,null,null] 从 1,2,3 拿 1 来，放入第一个空位 ==> [1,null,null]

  [1,null,null] 还剩下 2,3，拿出一个来，比如说 2，放入第2个空位 ==> [1,2,null]

    [1,2,null] 还剩下 3，只能放入最后一个空位 ==>  [1,2,3]

  ------ 还原 ------
  [1,null,null] 拿出 3 来，放入第 2 个空位 ==> [1,3,null]
    [1,3,null] 还剩下 2，只能放入最后一个空位 ==>  [1,3,2]
......
```

```typescript
function fullArrangement(nums: number[]): number[][] {
  let emptyIndex = 0; // 拿数组，emptyIndex 右边的数，拿出一个来填充 emptyIndex
  const result: number[][] = [];

  recursion(nums, 0, result);

  return result;
}

function recursion(
  nums: number[],
  emptyIndex: number,
  result: number[][]
): void {
  if (emptyIndex === nums.length - 1) {
    result.push(nums.slice());
    return; // 已经排完了
  }

  // 把 emptyIndex 后续的每一位都和当前位进行交换

  for (let i = emptyIndex; i < nums.length; i++) {
    swap(nums, emptyIndex, i);

    recursion(nums, emptyIndex + 1, result);

    // 排完后，需要还原
    swap(nums, emptyIndex, i);
  }
}

function swap(nums: number[], i: number, j: number): void {
  const s = nums[i];
  nums[i] = nums[j];
  nums[j] = s;
}
```

## 字典排序
