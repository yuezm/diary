# HTTP 从 1.0 到 1.1 到 2.0

## 什么是 HTTP

HTTP（Hyper Text Transfer Protocol）：超文本传输协议，用于传输超媒体文档的应用层协议。

### HTTP 作用

传输超媒体，HTTP 是万维网的数据通信的基础，设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。3 项构建 WWW 技术 HTML、HTTP、URI

超媒体：对超文本的术语延伸，包含图片、音频、视频、文本、超链接的非线性消息媒体

> 超文本（英语：Hypertext）是一种可以显示在电脑显示器或电子设备上的文本，现时超文本普遍以电子文档的方式存在，其中的文字包含有可以链接到其他字段或者文档的超链接，允许从当前阅读位置直接切换到超链接所指向的文字

1. 客户端-服务端模型：由客户端发起请求（Request），服务端返回响应（Response）的方式进行数据交互

请求方法 请求 URL HTTP 协议版本
请求头

实体

协议版本 HTTP 状态码 HTTP 状态信息
响应头

实体

1. 无状态协议：HTTP 自身不对通信状态进行保存
2. 文本协议
3. 无连接：HTTP 通信一次就需要 连接/断开 TCP，即 HTTP 开始通信时连接 TCP，结束通信时断开 TCP
4. 队首阻塞（Header Of Line Blocking）：每一个 HTTP 请求，都必须等待上一个 HTTP 响应才可以发送

HTTP 创建之初，只要用于传输文字，其中部分文字可能带有超链接，内容远远没有现在丰富， 排版也远远没有现在精美，交互也远远没有现在复杂，对于当时这种简单的应用场景，HTTP 表现得还可以。

但是随着互联网的高速发展，WEB2.0 的兴起，更多丰富的内容，更精美的排版，更加复杂的交互等等。导致随随便便一个网站的大小都会比原来的网站大很多，更不用说社交、电商网站，请求数量大，请求内容大，那么会引发一个问题 **加载速度**。我们讨论加载速度，首先排除带宽影响，因为我们主要讨论协议，讨论带宽没啥意义，即限制在恒定带宽下，来分析协议

#### 文本协议

HTTP1.\*是文本协议，文本协议具有可读性好，扩展性好等优点，但也具有浪费带宽，传输效率不如二进制协议高的缺点。那么 HTTP2 是如何在不改变 HTTP1.\*的语义情况下，提升传输效率呢

二进制分帧

在 HTTP 协议和 TCP 协议之间，加入二进制分帧层

Stream: 一个 HTTP2 连接的虚拟信道，具有双向承载传输，每个流都有一个唯一标识符，为了防止客户端和服务端标识符冲突，客户端发起的采用奇数 ID 服务端发起的采用偶数 ID
Message: 表示一个完整的请求和响应，由 N 个 Frame 组成
Frame: HTTP2 的的传输基本单元，帧分为 Headers Frame 和 Data Frame，对用 HTTP1.\*的 Header 和 Body

#### 无连接

由于 HTTP 无法复用连接，则每次 HTTP 发送请求时，都会发起 TCP 连接，HTTP 结束通信时断开 TCP 连接

1. 由于 TCP 三次握手会多出 1RTT 时间，额外增加延迟
2. 由于 TCP 的拥塞机制中的慢启动，新的连接总是要过一段时间才能高效传输

RTT: Round Trip Time，往返时间，从发送端发送数据开始，到接收到来自服务端的确认的时间间隔。可以使用 ping、tcpping 来测试

HTTP1.1 引入 头部，

```text
 Connection: Keep-Alive # 默认开启哈
 Keep-Alive: timeout=10 # 可以设置时间，也可以由服务器设置

 Connection: close # 表示关闭长连接，或者等待超时关闭
```

ngnix 服务器配置

```yaml
keepalive_timeout 60s;
```

注意的是，Connection 为 Hop-by-Hop 头部，只对单次转发有效，遇到缓存和代理则不再转发

长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升

#### Header Of Line Blocking

网络请求数量大，后续请求需要等待前面请求完成，由于请求数量巨大，严重影响加载

##### Pipelining

HTTP1.1 引入 Pipelining（流水线），客户端可以同时发送 N 个请求，并不需要等待前面的请求完成，但也存在以下问题

1. 服务器可能不支持
2. 代理服务器可能支持
3. 虽然请求可以同时发出，但是返回也是依次的，请注意，并不是 response 先返回先处理，而是按照 FIFO 原则，可能导致新的问题 Front of queue blocking（队列前阻塞）

所以有的浏览器要么默认关闭 Pipelining，要么直接就关闭了

[](https://www.chromium.org/developers/design-documents/network-stack/http-pipelining)

#### 域名分片

浏览器为每个域名建立多个连接，以实现并发请求。曾经默认的连接数量为 2 到 3 个，现在比较常用的并发连接数已经增加到 6 条。

为了增加并发，可以采用不同的域名来传输，从而提高性能

1. 资源限制，服务器保护
2. 操作系统对半开 TCP 数量限制

>

1. 增加了资源的消耗，换取用户的等待时间
2. 可以减少请求数据，静态资源服务器不需要 Cookie，将这些资源拆分出来，以减少传输大小

如果尝试大于这个数字，就有触发服务器 DoS 保护的风险

但并不是域名增加的越多越好，每增加一个域名，都要承担 资源消耗增加 + ”DNS 解析 + 三次握手 + 慢启动“ 的时间，需要寻找平衡点

搞一搞 prefetch

##### Multiplexing

多路复用允许对一个域名建立的 HTTP2 请求中，发起多个请求-响应，请求和响应都对应一个 Message，Message 信息由 Frame 承载，也可以设置每个帧的优先级（二进制分帧在别的地方介绍）

多路复用，同一个连接可创建多个 Stream，每个 Stream 里面可以传输多个 Frame，Stream Frame 可以混用，最终在客户端将 Frame 拼接为 Message

多路复用解决了 HTTP1.\*中的对头阻塞和队列前阻塞的问题，但为此又会引发一个新的问题

### HTTP2.0 依旧未解决的问题

## HTTP3.0

## HTTP 一些常见的误区

1. HTTP 协议必须基于 TCP/IP 协议簇
2. POST 请求前会发送一次请求
3. GET 请求不能携带 Body Entity
4. GET 请求对 URL 长度有限制
