# 4.12-4.18

## 微前端实践模型

### 基座模式

以主应用提供基本能力，例如权限、路由管理、日志、数据通信、加载子应用等；子应用契合各个业务线

**特点**：

1. 避免代码重复，有效的公用主应用提供的基本能力
2. UI 定制化较弱，主应用奠定了整个 UI 的风格

### 镶嵌模式

将通用功能做成子应用，在各个业务中插入使用

**特点**：

1. 可实现 UI 定制化，因为 UI 是各个自引用自身开发
2. 可实现按需整合
3. 实现较为复杂，需要考虑业务引用的菜单、路由、权限等等

## 多页面架构

通常来说，一个 _\*.html_ 为一个页面，多页面架构就是页面跳转时加载新的 HTML 文件

**特点**：

1. SEO
2. 首屏加载
3. 模板渲染：多页面架构不可能离开模板渲染，但模板渲染有个缺点，由于**对页面来说是全部替换，则需要全量更新 DOM**，性能损耗较大

## 单页面架构

即切换时，不切换 HTML，而是重新加载 javascript 和 css，以实现页面的从新渲染

**特点**：

1. SEO 不太好（国内）
2. 首屏加载较慢
3. 用户体验友好，不必刷新页面

### 框架选型

1. 队员是否能快速学习和接收（学习成本）
2. 框架生态（开发升本）
3. 后期是否好维护（维护成本）
4. 是否可以快速迁移，或者部分迁移（迁移成本）

### 兼容

1. polyfill，可兼容 API，但不发兼容新的语法
2. 语法转换，记录可全部兼容

## leetcode

### 最大数

```typescript
function largestNumber(nums: number[]): string {
  // 其实是比较数的大小，数最大的排前面肯定是最大的数
  /**
   * 比较规则：
   * 1. 如果数一样长，则依次比较，大的放前面
   * 2. 如果数不一样长，则需要对短数进行特殊处理，例如 333 34，肯定是 34333 比 33334 大，而 99 和 9993 ，肯定是 999993 比 99399 大
   *  ==> 则对于短数，比较时自动添加数的最后一位进行比较
   */
}
```

[最大数](https://leetcode-cn.com/problems/largest-number/)

### 实现 Trie (前缀树)

[实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

### 打家劫舍 II

```typescript
/**
 * 此题难点在于存在环，第一家和最后一家是相邻的，此时如果直接动态规划，则存在二义性
 *   第1假状态和最后一家有关；最后一家和【第一家，倒数第二家】有关
 *
 * 由于此时出现了二义性，则我们把二义性排除掉，分为两种情况
 *  1. 假设第一家没抢：则可以抢到最后一家
 *  2. 假设第一家抢了：则不能抢最后一家
 *
 * 比较条件1、条件2 谁的取值大
 */
function rob(nums: number[]): number {}
```

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)
