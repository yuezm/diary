# 11 月第 1 周

## Javascript

## C++

## 网络

### 传输层

传输层特点：

1. 进程之间逻辑连接，无需关心下层如何实现
2. 只存在于端系统中，在链路及网络层中无该协议
3. 由于网络层的只关心`数据报`，而不关心连接，所以传输层连接是否可靠需要自己实现

#### 多路复用，多路分解

**多路复用**

多个`应用层`通过`套接字`将报文传输给`传输层`，传输层将数据封装为`报文段`交给网络层

**多路分解**

传输层通过`四元信息`（源、目标 IP，源、目标端口）来决定将信息交个哪个套接字

##### TCP 多路分解

TCP 以`四元组 源 IP，源端口，目标 IP，目标端口`来确定唯一一个 Socket，当传输层判定四元信息一致时，会讲给已创建的 Socket,如果不一致则另外开启进程，绑定端口（创建 Socket）来接收信息

**目前有高性能服务器，只有一个进程，但不同的四元组连接时，虽然套接字连接到同一个进程，但是服务器会为每一个连接开启一个`线程`来绑定套接字**

#### 四元信息之端口

UPD 报文段和 TCP 报文段端口长度都为 16 位，即端口最大为 2^16-1 = 65535

```
0~1023 周知端口，紧密绑定（binding）于一些服务
1024~49151 注册端口，松散的绑定一些服务
49152~65515 动态端口
```

#### UDP

**UPD 特点：**

1. 流量控制和何时发送分组更加精细
2. 无需连接
3. 报文体积小
4. 无拥塞机制（需要手动控制流量）

##### UPD 报文组成

1. 16 位源端口
2. 16 位目标端口
3. 16 位长度，UPD 报文字节数（首部+数据）
4. 16 位检验和
5. 数据

**检验和**：检验数据是否正确传达，`检验和 = 0 - (源端口+目标端口+长度)`，如果计算溢出，则回卷（将溢出的数加到末尾）。在客户端通过检测 `源端口+目标端口+长度+检验和==0`，则数据正确

#### TCP

##### 如何保证可靠连接

1. 分组序号：将分组编号，以便确认哪一个分组未到达或有错误
2. 定时器：发送分组时，启动定时器，如果超过时间未得到确认，则重发分组
3. 检验和：客户端校验分组是否正确
4. 确认反馈：客户端确认分组已正确到达
5. 否定反馈：客户端确认分组错误，请求重发

##### TCP 性能

TCP 属于`停等协议`，即在未得到确认之前不会接收上层数据，所以为了提高性能，使用`流水线`，即批量发送分组，批量确认分组

**回退 N 步**

发送端维护：最前一个发送但未确认的分组序号（`基序号`），最前一个即将发送的分组序号（`下一个序号`）
客户端无需缓存分组，且如果当前分组是无序的，则直接丢弃，等待发送端重传所有失序分组

**选择重传**

发送端维护：最前一个发送但未确认的分组序号（`基序号`），最前一个即将发送的分组序号（`下一个序号`）。如果确认序号等于基序号，则窗口向右滑动；如果窗口落在下一个序号内，则发送分组
客户端维护：维护所有失序的分组，等到接收到顺序的分组，再交给上层服务

##### TCP 特点

1. 面向连接，三次握手建立连接
2. 无法手动控制流量，通过拥塞机制和接收窗口控制流量
3. 无法确定报文合适发送，从上层接收的数据存储在`发送缓存`中，在适当的时候 TCP 从发送缓存中取出数据发送
4. 首部较大，20 字节

`应用层 => 发送缓存 => 数据报 ... 数据报 => 接收缓存 => 应用层`

MTU：最大传输数据，目前以太网和 PPP 链路中一般为 1500 字节
MSS：最大报文段**不包含首部的数据**，一般 TCP/IP 为 40 字节，则 MTU 为 1460 字节

##### TCP 报文

1. 16 为源端口
2. 16 位目标端口
3. 32 序号：初始序号并不都是从 0 开始，可以随机生成
4. 32 位确认号：确认号为下次期望得到的数据序号
5. 5 位首部长度
6. 5 位暂未使用
7. 6 位标志位：SYN，ACK，RST，FIN，（URC，PSH）
8. 16 位接收窗口
9. 16 位检验和
10. 紧急数据指针

11. 选项
12. 数据

##### TCP 的可靠数据传输

1. 分组序号：将分组编号，且报文段的序号是`报文首字节的字节流编号`

   如：50000 字节，MSS 1000，假设初始序号为 0，分组 1=0；分组 2=1000，分组 3=2000；...

2. 检验和：接收端利用检验和来校验数据是否正确到达，即校验数据的正确性，但`检验和正确并不能保证数据一定是正确的`

   如：因为检验和是通过累计的方式来判断数据是否正确，如果某个计算因子减少，另一个计算因子增加，则刚好会造成检验和的校验正确

3. 定时器：定时器重传机制，定时器的初始值一般为 1s，后续由 RTT 计算而得

   1. 单一重传定时器：理论是每个分组都维护一个定时器，但是定时器开销过大，所以推荐都是单一重传定时器
   2. 超时加倍：如果定时器超时后，超时时间将会设为原来的 2 倍

4. 确认、否定确认：发送端检验 ack 码来校验接收端是否正确收到

5. 冗余 ACK：当接收端接收到一个分组时，如果`已经接收过了分组，则丢弃该分组，并发送冗余 ACK`，否则发送 ACK

   1. 快速重传：当发送端接收到已经确认过的 ack 码 3 次（加上第一个确认，总共为 4 次），则快速重传当前 `ack码表示的分组`

6. 选择确认 = 回退 N 步 + 选择重传：TCP 的流水线是回退 N 步+选择重传的结合体

##### TCP 流量控制

目的：控制 TCP 连接内的流量

在 TCP 报文中，存在`接收窗口`,用来抑制发送端，接收窗口表明接收端还能接收多少数据

rwnd(接收窗口数值) = 接收端缓冲区大小 - 已缓存未交给上层的数据大小

```
TCP发送端 发送分组 TCP接收端
TCP接收端 确认 TCP发送端时，带上接收窗口数值，告诉发送端最大的发送分组大小，如果接收窗口等于0，则发送端会发送1字节报文，等待接收端反馈
```

##### TCP 拥塞控制

目的：控制链路流量

特点：

1. 当 TCP 得到正确 ack 时，认为链路通常，则增加发送窗口大小
2. 当 TCP 超时，或得到 3 个冗余 ack 时，则认为链路阻塞，减少发送窗口大小

**拥塞机制的三种方式**

1. 慢启动：在慢启动阶段，发送窗口大小呈指数增长，一般初始值为 cwnd = 1MSS，得到正确的 ack 后，则增大为 cwnd = 2MSS，再得到正确 ack 后，增大位 cwnd = 4MSS，以此类推

慢启动类似贪心的孩子，不停的加倍讨要糖果，直到得到不允许再拿更多  
在慢启动阶段，发送窗口指数级别增大，直到遇到`定时器超时`。当触发超时事件后，设置阈值 ssthresh = cwnd / 2；且 cwnd = 1，继续进行慢启动。  
当 cwnd >= ssthresh 时，继续指数增长显示不合适，此时进入`拥塞避免`

2. 拥塞避免：该阶段 cwnd 不会像慢启动那样疯狂增长，在拥塞避免节点，如果接收到正确的 ack，则 cwnd +=1MSS，即每次增加一个

3. 快速重传：接收到 3 个冗余 ack 后，执行快速重传，cwnd 会减少但不会像定时器超时那样暴力。该节点 ssthresh = cwnd / 2;且 cwnd = ssthresh+3; 并快速重传丢报文段

4. 快速恢复：该阶段接收重复 ACK 时，cwnd += 1MSS，如果接收到新的 ACK 时，则 cwnd = ssthresh。转换为拥塞避免

##### TCP 三次握手，四次挥手

**三次握手**

1. 客户端将 标志位 SYN=1，序号 seq = 随机数字 c1，发送给服务端。客户端进入 SYN_SEND;
2. 服务端接收到报文段，分配资源和初始化变量，并放报文段：标志位 SYN=1，seq=随机数字 s1,ack=c1+1。服务器进入 SYN_RECV
3. 客户端接收到报文段，检验 ack，如果正确则分配资源及初始化变量，并发送报文段：标志位 SYN=0,ACK=1,seq=c1+1,ack=s1+1。如果服务端通过了 ack 校验则进入 ESTABLISHED（此阶段客户端可以发送数据了）

**四次挥手**

A 端发送报文：标志位 FIN=1，seq=传输最后的序号，进入 FIN_WAIT_1
B 端接收报文，并发送确认报文：标志位 ACK=1，ack=seq+1,此时 A 端进入 FIN_WAIT_2

B 发送报文：FIN=1，seq=最后的传输序号,进入 TIME_WAIT 状态，等待时间为 2MSL
A 端接收报文，并发送 ACK=1,ack=seq+1，此时 B 端接收到 ACK 后同时断开连接

MSL： 报文最大生命周期

**为什么需要 TIME_WAIT**

1. 确保发起 FIN 方能接收到 ACK
2. 报文可能被混淆，其他的连接被当成本次连接使用。所以在 2MSL 内，其他服务无法绑定该端口

## 算法

## Leetcode
