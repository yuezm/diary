# 10 月第三周

## 计划完成情况

1. <font color="red">计算机网络 第二章未完成</font>
2. <font color="red">编译器设计 第二章未完成</font>

## 下周计划

1. 推进进入 计算机网络完成到第 3 章，编译器完成到第 3 章，算法 4 章完成
2. 下周需要想想文章题目，10 月份两篇文章还未完成（因为 996，暂定只写一遍文章：typescript 类型）

## Javascript

## C++

## 网络

## 网络组成

1. 网络硬件

- 主机（端系统）：网络的终端，包括服务器，PC,Note 等

- 分组交换机

  1. 路由器：网络层的分组交换机，不同网络之间的数据传输，工作于网络层
  2. 链路层交换机（交换机）：链路层的分组交换机，同一个网络的数据传输，工作于链路层

- 物理媒介等
  1. 双绞铜线
  2. 同轴电缆
  3. 光纤
  4. 陆地无线电
  5. 卫星无线电

2. 网络软件

- 应用软件
- 协议：包含路由转发协议，IP 协议，TCP 协议等
- RFC 规范

3. 网络提供商（ISP）

- 第一层 ISP
- 接入 ISP
- 内容提供商

### 接入

#### 家庭接入

1. 数字线路
2. 电缆
3. 拨号
4. 其他（不熟悉）

### 企业接入

1. 以太网
2. WIFI

### 广域无限接入

2G / 3G / 4G

### 网络核心

1. **分组交换**

将数据分为小段（分组）进行传输，在源和目的地之间的`链路和分组交换器`中传输

**数据存储转发（路由器）、路由转发协议**

数据存储转发：路由器转发必须等到整个分组全部加载完毕，才开始传输。并不是想象中的流式传输（`存储转发时延`）

路由转发协议：路由器通常连接了很多链路，路由转发协议决定路由器将该分组发向哪一个链路

**输出缓存、排队延时、丢包**

输出缓存：分组交换机存在特性，`存储转发的分组`，当链路空闲时，才会开始传输，如果链路不空闲，则会不停的累积。

排队延时：输出缓存导致的延时

丢包：输出缓存空间是有限的，如果输出缓存满了，还有新分组进入，则会出现分组丢弃

2. **电路交换**

**电路中预先分配了通信嗦需要的资源，直接可以使用，无序排队**

- 频率复用
- 电路复用

3. **网络的网络、网络模型**

1) 第一层 ISP 互相连接
2) 内容提供商接入第一层 ISP
3) 接入层 ISP 接入第一层 ISP 和内容提供商
4) 普通用户接入 提供 ISP

### 网络分层

1. 应用层（表现层，会话层）：网络的最上层，应用程序如何接受和发送网络信息，如 HTTP，FTP，SMTP，DNS 协议 等，此层数据称为`报文`
2. 传输层：负责数据传输，为应用程序之间的数据传输信息，此层数据称为`报文段`
3. 网络层：负责主机之间网络信息传递，此层数据称为`数据报`
4. 链路层：负责链路节点之间的数据传递，此层数据称为`帧`
5. 物理层：物理层也是链路传递，但在链路上增加了物理媒介

## 算法

### 图

1. 是否连通区分

- 连通图
- 非连通图

2. 是否回环

- 回环图
- 非回环图

3. 是否稠密

- 稠密图
- 非稠密图

4. 边是否存在方向

- 无向图
- 向量图

5. 二分图
6. 权重图

### 无向图

#### 表示方式

1. 邻接矩阵
   以矩阵形式存储数据每一个节点，两个节点对用的点则表示边

```
[
  [ 0, 1 ,0 ]
  [ 1, 0, 0 ]
  [ 0, 0, 0 ]
]
// 表示 0,1,2 三个节点的情况，0，1 之间存在边
```

**邻接矩阵优化**

由于无向图和方向无关，则节点之间无需存储两遍，例如 0,1 节点边被存储勒两次。所采用的的优化方式`砍掉另一半的存储`

缺点：空间消耗太大

2. 边数组

以数组形式保存存在边的节点

```
[ [0,1] ] // 0，1存在边
```

缺点：处理任何一个节点都需要遍历整个图

3. 临接表数组

```
[
  [1]
  [0]
]
// 0，1 节点存在边
```

## 编译器

### 编译器简介

将源代码（字符串）转换为可执行代码（文件）的程序

#### 编译器步骤

前端编译 => 中间代码 => 优化 => 中间代码 => 后端编译 => 可执行文件

#### 编译器和解释器区别

1. 编译器将源代码编译为可执行文件，运行文件得到结果
2. 解释器是直接运行源代码得到结果

#### 编译器特性

1. 保证源代码的执行正确性
2. 在用户可探查的情况下优化

### 前端

#### 词法分析

1. 词法生成器
2. 手写词法分析

##### 识别器形式化

1. 有限自动机

- S：有限状态机集合
- ∑：识别的字母表
- δ：转移函数
- S<sub>0</sub>：起始状态
- S<sub>A</sub>：接收集合状态

2. 正则

- 连接：AB
- 选择：A|B
- 柯林循环：A\*

## Leetcode

### 反转链表

思路：使用三个节点分别存储：

```
Prev->Target->Next

Target->Prev

Prev = Target
Target = Next
Next = Next->next
```

**千万别忘记，把 `header->next = null`!!!**

```
ListNode* reverseList(ListNode* head) {
  if(head == nullptr) return head;

  ListNode* target = head->next;
  ListNode* next = nullptr;

  head->next = nullptr;
  while(target != nullptr){
    next = target->next;

    target->next = head;

    head = target;
    target = next;
  }

  return head;
}
```

[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

### 回文链表

[回文链表](https://leetcode-cn.com/problems/reverse-linked-list/https://leetcode-cn.com/problems/palindrome-linked-list/submissions/)

思路 1：找个数组存起来，判断是否为回文数组
思路 2：将链表中间反转（前半段反转，后半段不变），然后不断遍历判断是否相等

### 最近三数近似和

思路：排序后，先取最后一位，然后在剩余的找到匹配最近的值

```
int threeSumClosest(vector<int>& nums, int target) {
  sort(nums.begin(), nums.end());
  int result = nums[0] + nums[1] + nums[2];

  int i = 0;
  int len = nums.size();

  while (i < len) {
    // 以nums[i] 为几点，找到匹配的数值
    if ((target > 0 && nums[i] >= target) || (target < 0 && nums[i] >= 0)) break;

    int j = i + 1;
    int z = len - 1;

    while (j < z) {
      int n = nums[i] + nums[j] + nums[z];
      if (n == target) return target;
      if (n < target) {
        j++;
      } else {
        z--;
      }
      if (abs(result - target) > abs(n - target)) {
        result = n;
      }
    }
    i++;
  }

  return result;
}
```

[三数之和](https://leetcode-cn.com/problems/3sum-closest/submissions/)
