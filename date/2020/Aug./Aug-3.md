# AUG-3.md

## CS

### 3D

#### 投影绘线

3D 投影：2D 屏幕上，不可能存在 XYZ 立体轴，所以对于 3D 图形，可以想象成将 3D 图形”拍平“，置于屏幕上

    - 正交投影：正方体的各个面相互平行
    - 透视投射：平行线段在远处收敛为一个点

线框渲染：当所有的点都从 3D 转换为 2D 时，我们可以使用画 2D 线的手段来绘制这些点

三角形：三角形可以绘制更复杂的图形，三个点可以确定一个面，更多的三角形意味着画面更加精细，但意味着更大的计算了

#### 填充图形

扫描线性渲染：对于一个复杂的图形，计算图形 ”上下“、”左右“ 的位置，然后从上到下，从左到右，对图形占位的每个像素进行填充

**抗锯齿**：在进行填充时，对于完全处于图形内部的像素直接涂色，而对处于图形边界的像素涂色时颜色浅一点

#### 遮挡

* 画家算法：先绘制远处的，在绘制近处的，以近处的覆盖远处的
* 深度缓冲：记录每个像素距离摄像机的位置，在内存存储一个数字矩阵，它总是记录多边形的距离和深度缓冲中较小（较近）的那个，在进行绘制时，根据记录值进行填充

背面剔除：三角形存在正面和反面，一般来说总是展示正面，而反面由于不展示则会被忽略，所以当从反面看的时候，图形会消失（CF 卡 BUG）

#### 阴影

* 平面着色：距离灯光越近，越亮；反之越暗。着色时边界明显，效果比较差
* 高洛德着色、冯着色等等

#### 纹理

#### 3D 加速

1. 特点的硬件来加速（GPU）
2. 分解 3D 场景，并行计算

### 计算机网络

LAN：计算机近距离构成的小型网络（局域网 Local Area Networks）
MAC: 媒体访问控制地址，每个设备的 MAC 地址唯一

**以太网**: 以太网向整个链路发送信息，每个信息头部会携带目标的 MAC 地址，虽然每个机器都会收到信息，但只有 MAC 地址匹配的计算机才会处理信息

冲突：多台计算机同时对链路进行写入，就像两个人同时讲话一样，根本不知道在说啥。解决方法时**停止传输，过一会在试试**

指数退避：当计算机检测到冲突时，就会在重试前等待一段时间，再重试时如果再次发生冲突，则等待时间指数式增大。例如第一次等待 1s，第 2 次等待 2s，第 3 次等待 4s...

冲突域：同一个载体及载体中的所有设备。即使存在指数退避，也不可能将很多计算机连接在一根网线上，所以将计算机分开，由交换机连接

#### 信息交换

1. 电路交换
2. 报文交换
3. 分组交换

## LeetCode

### 是否为平衡二叉树

平衡二叉树：每一个节点的左节点深度和右节点深度差值不超过1

思路：深度递归

1. 自顶而下，先判断当前节点是否为平衡节点，再判断左右节点是否为平衡节点
2. 自底而上，先判断左右节点是否为平衡节点，在判断当前节点是否为平衡节点（少去自顶而下的重复计算时间）

``` typescript
function isBalanced(root: TreeNode | null): boolean {
  return height(root) !== -1;
}

// 计算当前树的高度，如果平衡，则为正数；否则为-1
function height(root: TreeNode | null): number {
  if (root === null) return 0;

  const left = height(root.left);

  if (left === -1) return -1;

  const right = height(root.right);

  if (right === -1) return -1;

  return Math.abs(left - right) <= 1 ? Math.max(left, right) + 1 : -1;
}
```

#### 鸡蛋掉落

思路：
 
 此处存在两种变化，鸡蛋的变化（K）, 楼梯数量的变化（N），那么存在两种控制变量（ `dp[k][n]` ，n 为楼梯数，而非楼层数），由谁做第一个索引，影响不大
 
 **递推公式** 
 
 `dp[k][n] = xxx`
   

  1. 问题1： 先假设鸡蛋足够多，那么肯定是先采用二分法（中间楼层扔一个鸡蛋，由于此处存在两个变量，不能直接中间一刀切），那到底是中间哪一层呢？不妨做个假设，在楼层 j 扔下鸡蛋，则出现如下情况

      1. 鸡蛋碎了，则向下移动 dp[k-1][j-1]
      2. 鸡蛋没碎，则向上移动 dp[k][n-j]

    本题取的是最少次数，但是这个最小次数是保证寻找到鸡蛋不碎的楼层，所以，**此处是用 max 而非 min** ===> `dp[k][n] = max(dp[k-1][j-1], dp[k][n-j) + 1`
 

  2. 问题2：得到了递推公式，那么如何求出最佳 j 呢？观察 dp[k-1][j-1], dp[k][n-j]，在 k 不变下，

        1. dp[k-1][j-1] 单调递增
        2. dp[k][n-j] 单调递减

   则，两个函数最小值就在  dp[k-1][j-1], dp[k][n-j] 相交处，ps 此处相交可能是个小数，那么就得**判断该小数前后两个整数，并去最小值**
 
  **特殊情况**

  1. 鸡蛋为0：那就没必要扔了，都是 0  ===>  dp[0][ 0 ~ n ] = 0
  2. 鸡蛋为1：那也没必要算了，一层一层扔就行了 ===> dp[1][ 0 ~ n ] = n;
  3. 楼层为0：那就没必要扔了，都是 0  ===>  dp[ 0 ~ k ][ 0 ] = 0
  4. 楼层为1：那也没必要算了，有鸡蛋就扔一下，没有就没得扔  dp[ 0 ]][ 1 ] = 0， dp[ 1 ~ k ]][ 1 ] = 1

 
 **存储**
  
  由于存在两个控制变量，所以使用 **二维数组** 存储

``` typescript
function superEggDrop(K: number, N: number): number {
  const dp: number[][] = [];
  for (let i = 0; i <= K; i++) {
    dp[ i ] = new Array(N + 1).fill(0);
  }

  // 特殊规则 1，已包含于初始化

  // 特殊规则 2
  for (let i = 1; i <= N; i++) {
    dp[ 1 ][ i ] = i;
  }

  // 特殊规则3，包含于初始化

  // 特殊规则4
  for (let i = 1; i <= K; i++) {
    dp[ i ][ 1 ] = 1;
  }

  // 开始计算咯，由于在极值情况下已单独处理，则无序考虑
  for (let egg = 2; egg <= K; egg++) {
    for (let stairs = 2; stairs <= N; stairs++) {
      // 寻找最佳的楼梯
      let left = 0, right = stairs;
      while (left < right - 1) {
        const middle = (left + right) >> 1;

        const middleLeftValue = dp[ egg - 1 ][ middle - 1 ]; // 递增
        const middleRightValue = dp[ egg ][ stairs - middle ]; // 递减

        if (middleLeftValue === middleRightValue) {
          left = right = middle;
        } else if (middleLeftValue < middleRightValue) {
          // 往右移动
          left = middle; // 为什么不想普通二分法一样，因为真正的相交点可能是小数，例如(realMiddle = 4.2, middle = 4)，如果直接 + 1 ，则超出了
        } else {
          right = middle;
        }
      }

      // 寻找到最佳扔鸡蛋楼梯后，开始扔鸡蛋，由于最佳楼梯可能为小数，所以需要判断最佳楼梯左右（left、right）

      dp[ egg ][ stairs ] = Math.min(
        Math.max(dp[ egg - 1 ][ left - 1 ], dp[ egg ][ stairs - left ]),
        Math.max(dp[ egg - 1 ][ right - 1 ], dp[ egg ][ stairs - right ]),
      ) + 1;
    }
  }

  return dp[ K ][ N ];
};
```
